// <copyright file="SqlBulkCopySourceGenerator.cs" company="Olibos">
// Copyright (c) Olibos. All rights reserved.
// </copyright>

namespace Olibos.Data.SqlClient.SqlBulkCopy;

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

/// <summary>
/// A Roslyn incremental source generator that automatically creates optimized SQL bulk copy adapters for classes decorated with the <see cref="SqlBulkCopyAttribute"/>.
/// </summary>
/// <remarks>
/// <para>
/// This generator analyzes the compilation for classes annotated with <see cref="SqlBulkCopyAttribute"/> and generates extension methods
/// on Microsoft.Data.SqlClient.SqlBulkCopy that accept IAsyncEnumerable{T} of the annotated class.
/// </para>
/// <para>
/// For each annotated class, the generator:
/// <list type="number">
///   <item><description>Extracts public properties from the class using semantic analysis</description></item>
///   <item><description>Generates a custom <see cref="System.Data.Common.DbDataReader"/> implementation</description></item>
///   <item><description>Creates an extension method <c>WriteToServerAsync</c> for seamless bulk copying</description></item>
/// </list>
/// </para>
/// <para>
/// The generated code is fully async-compatible and supports cancellation tokens for long-running operations.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// [SqlBulkCopy]
/// public class Product
/// {
///     public int Id { get; set; }
///     public string Name { get; set; }
///     public decimal Price { get; set; }
/// }
///
/// // Generated extension method becomes available:
/// // public static async Task WriteToServerAsync(
/// //     this SqlBulkCopy sql,
/// //     IAsyncEnumerable&lt;Product&gt; items,
/// //     CancellationToken cancellationToken = default)
///
/// var bulkCopy = new SqlBulkCopy(connection) { DestinationTableName = "dbo.Products" };
/// await bulkCopy.WriteToServerAsync(GetProductsAsync());
/// </code>
/// </example>
[Generator(LanguageNames.CSharp)]
public class SqlBulkCopySourceGenerator : IIncrementalGenerator
{
    private const string SqlBulkCopyAttribute =
        """
        // <auto-generated/>
        namespace Olibos.Data.SqlClient.SqlBulkCopy;
        
        [System.AttributeUsage(System.AttributeTargets.Class)]
        [System.Diagnostics.Conditional("AOT")]
        internal class SqlBulkCopyAttribute : System.Attribute
        {
        }
        """;

    private const string BaseAdapterClass =
        """
        // <auto-generated/>
        #nullable enable
        namespace Olibos.Data.SqlClient.SqlBulkCopy;
        
        using System;
        using System.Collections;
        using System.Collections.Generic;
        using System.Data.Common;
        using System.Threading;
        using System.Threading.Tasks;
        using Microsoft.Data.SqlClient;
        
        public static partial class SqlBulkCopyExtensions
        {
            private abstract class BaseAsyncEnumerableReader : DbDataReader
            {
                public override int RecordsAffected => throw new NotSupportedException();
            
                public override bool HasRows => throw new NotSupportedException();
            
                public override bool IsClosed => throw new NotSupportedException();
            
                public override int Depth => throw new NotSupportedException();
            
                public override object this[int ordinal] => throw new NotSupportedException();
            
                public override object this[string name] => throw new NotSupportedException();
            
                public override bool GetBoolean(int ordinal) => throw new NotSupportedException();
            
                public override byte GetByte(int ordinal) => throw new NotSupportedException();
            
                public override long GetBytes(int ordinal, long dataOffset, byte[]? buffer, int bufferOffset, int length)
                    => throw new NotSupportedException();
            
                public override char GetChar(int ordinal) => throw new NotSupportedException();
            
                public override long GetChars(int ordinal, long dataOffset, char[]? buffer, int bufferOffset, int length)
                    => throw new NotSupportedException();
            
                public override string GetDataTypeName(int ordinal) => throw new NotSupportedException();
            
                public override DateTime GetDateTime(int ordinal) => throw new NotSupportedException();
            
                public override decimal GetDecimal(int ordinal) => throw new NotSupportedException();
            
                public override double GetDouble(int ordinal) => throw new NotSupportedException();
            
                public override Type GetFieldType(int ordinal) => throw new NotSupportedException();
            
                public override float GetFloat(int ordinal) => throw new NotSupportedException();
            
                public override Guid GetGuid(int ordinal) => throw new NotSupportedException();
            
                public override short GetInt16(int ordinal) => throw new NotSupportedException();
            
                public override int GetInt32(int ordinal) => throw new NotSupportedException();
            
                public override long GetInt64(int ordinal) => throw new NotSupportedException();
            
                public override string GetName(int ordinal) => throw new NotSupportedException();
            
                public override string GetString(int ordinal) => throw new NotSupportedException();
            
                public override int GetValues(object[] values) => throw new NotSupportedException();
            
                public override bool IsDBNull(int ordinal) => throw new NotSupportedException();
            
                public override bool NextResult() => throw new NotSupportedException();
            
                public override bool Read() => throw new NotSupportedException();
                
                public override IEnumerator GetEnumerator() => throw new NotSupportedException();
            }
        }
        """;

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                "SqlBulkCopyAttribute.g.cs",
                SourceText.From(SqlBulkCopyAttribute, Encoding.UTF8));
        });

        // Filter classes annotated with the [SqlBulkCopy] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(c => c is not null)
            .Select((c, _) => c ?? throw new ArgumentNullException(nameof(c)));

        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the [SqlBulkCopy] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate.</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static ClassDeclarationSyntax? GetClassDeclarationForSourceGen(GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        foreach (AttributeSyntax attributeSyntax in classDeclarationSyntax.AttributeLists.SelectMany(c => c.Attributes))
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();
            if (attributeName == "Olibos.Data.SqlClient.SqlBulkCopy.SqlBulkCopyAttribute")
            {
                return classDeclarationSyntax;
            }
        }

        return null;
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [SqlBulkCopy] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [SqlBulkCopy] attribute that trigger the generate action.</param>
    private static void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        if (classDeclarations.Length > 0)
        {
            context.AddSource(
                "BaseAdapterClass.g.cs",
                SourceText.From(BaseAdapterClass, Encoding.UTF8));
        }

        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol) continue;

            var fullName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var properties = classSymbol.GetMembers()
                .OfType<IPropertySymbol>();
            int count = 0;
            var values = new StringBuilder();
            var ordinals = new StringBuilder();
            const string spacing = "                ";
            var wrapperClassName = fullName.Replace("global::", string.Empty).Replace('.', '_');
            foreach (var propertyName in properties.Select(p => p.Name))
            {
                values.Append(spacing)
                    .Append(count)
                    .Append(" => _enumerator.Current.")
                    .Append(propertyName)
                    .AppendLine(",");
                ordinals.Append(spacing)
                    .Append('"')
                    .Append(propertyName)
                    .Append("\" => ")
                    .Append(count)
                    .AppendLine(",");
                count++;
            }

            var code = $$"""
                         // <auto-generated/>
                         namespace Olibos.Data.SqlClient.SqlBulkCopy;

                         using System;
                         using System.Collections.Generic;
                         using System.Threading;
                         using System.Threading.Tasks;
                         using Microsoft.Data.SqlClient;
                         
                         public static partial class SqlBulkCopyExtensions
                         {
                             public static async Task WriteToServerAsync(this SqlBulkCopy sql, IAsyncEnumerable<{{fullName}}> items, CancellationToken cancellationToken = default)
                             {
                                 await using var reader = new {{wrapperClassName}}(items);
                                 await sql.WriteToServerAsync(reader, cancellationToken).ConfigureAwait(false);
                             }
                             
                             private class {{wrapperClassName}}(IAsyncEnumerable<{{fullName}}> enumerable, CancellationToken cancellationToken = default) : BaseAsyncEnumerableReader
                             {
                                 private readonly IAsyncEnumerator<{{fullName}}> _enumerator = enumerable.GetAsyncEnumerator(cancellationToken);
                                 
                                 public override int GetOrdinal(string name)
                                     => name switch
                                    {
                         {{ordinals}}
                                         _ => throw new ArgumentOutOfRangeException(nameof(name))
                                    };
                             
                                 public override object GetValue(int ordinal)
                                     => ordinal switch
                                    {
                         {{values}}
                                         _ => throw new ArgumentOutOfRangeException(nameof(ordinal))
                                    };
                             
                                 public override int FieldCount => {{count}};
                             
                                 public override ValueTask DisposeAsync() => _enumerator.DisposeAsync();
                                 
                                 public override async Task<bool> ReadAsync(CancellationToken cancellationToken)
                                     => await _enumerator.MoveNextAsync().ConfigureAwait(false);
                             }
                         }
                         """;

            context.AddSource($"{fullName.Replace("global::", string.Empty)}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
}